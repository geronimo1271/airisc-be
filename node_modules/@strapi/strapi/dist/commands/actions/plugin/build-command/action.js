"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const boxen_1 = __importDefault(require("boxen"));
const chalk_1 = __importDefault(require("chalk"));
const pack_up_1 = require("@strapi/pack-up");
const helpers_1 = require("../../../utils/helpers");
const logger_1 = require("../../../utils/logger");
const pkg_1 = require("../../../utils/pkg");
exports.default = async ({ force, ...opts }) => {
    const logger = (0, logger_1.createLogger)({ debug: opts.debug, silent: opts.silent, timestamp: false });
    try {
        /**
         * Notify users this is an experimental command and get them to approve first
         * this can be opted out by setting the argument --yes
         */
        await (0, helpers_1.notifyExperimentalCommand)({ force });
        const cwd = process.cwd();
        const pkg = await (0, pkg_1.loadPkg)({ cwd, logger });
        const pkgJson = await (0, pkg_1.validatePkg)({ pkg });
        if (!pkgJson.exports['./strapi-admin'] && !pkgJson.exports['./strapi-server']) {
            throw new Error('You need to have either a strapi-admin or strapi-server export in your package.json');
        }
        const bundles = [];
        if (pkgJson.exports['./strapi-admin']) {
            const exp = pkgJson.exports['./strapi-admin'];
            const bundle = {
                source: exp.source,
                import: exp.import,
                require: exp.require,
                runtime: 'web',
            };
            if (exp.types) {
                bundle.types = exp.types;
                // TODO: should this be sliced from the source path...?
                bundle.tsconfig = './admin/tsconfig.build.json';
            }
            bundles.push(bundle);
        }
        if (pkgJson.exports['./strapi-server']) {
            const exp = pkgJson.exports['./strapi-server'];
            const bundle = {
                source: exp.source,
                import: exp.import,
                require: exp.require,
                runtime: 'node',
            };
            if (exp.types) {
                bundle.types = exp.types;
                // TODO: should this be sliced from the source path...?
                bundle.tsconfig = './server/tsconfig.build.json';
            }
            bundles.push(bundle);
        }
        await (0, pack_up_1.build)({
            cwd,
            configFile: false,
            config: {
                bundles,
                dist: './dist',
                /**
                 * ignore the exports map of a plugin, because we're streamlining the
                 * process and ensuring the server package and admin package are built
                 * with the correct runtime and their individual tsconfigs
                 */
                exports: {},
            },
            ...opts,
        });
    }
    catch (err) {
        logger.error('There seems to be an unexpected error, try again with --debug for more information \n');
        if (err instanceof Error && err.stack) {
            console.log(chalk_1.default.red((0, boxen_1.default)(err.stack, {
                padding: 1,
                align: 'left',
            })));
        }
        process.exit(1);
    }
};
//# sourceMappingURL=action.js.map